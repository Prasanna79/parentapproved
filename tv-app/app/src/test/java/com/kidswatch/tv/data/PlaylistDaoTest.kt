package com.kidswatch.tv.data

import com.kidswatch.tv.data.cache.PlaylistEntity
import com.kidswatch.tv.data.cache.PlaylistDao
import kotlinx.coroutines.test.runTest
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

/**
 * Unit tests for PlaylistDao using a fake in-memory implementation.
 * These test the DAO contract without needing Android/Room.
 */
class PlaylistDaoTest {

    private lateinit var dao: FakePlaylistDao

    @Before
    fun setup() {
        dao = FakePlaylistDao()
    }

    @Test
    fun insertPlaylist_returnsAutoGeneratedId() = runTest {
        val id = dao.insert(PlaylistEntity(youtubePlaylistId = "PLtest1", displayName = "Test 1"))
        assertTrue("Insert should return id > 0", id > 0)
    }

    @Test
    fun getAll_returnsInsertedPlaylists() = runTest {
        dao.insert(PlaylistEntity(youtubePlaylistId = "PL1", displayName = "A"))
        dao.insert(PlaylistEntity(youtubePlaylistId = "PL2", displayName = "B"))
        dao.insert(PlaylistEntity(youtubePlaylistId = "PL3", displayName = "C"))
        val all = dao.getAll()
        assertEquals(3, all.size)
    }

    @Test
    fun getByYoutubeId_returnsCorrectPlaylist() = runTest {
        dao.insert(PlaylistEntity(youtubePlaylistId = "PLfoo", displayName = "Foo"))
        dao.insert(PlaylistEntity(youtubePlaylistId = "PLbar", displayName = "Bar"))
        val result = dao.getByYoutubeId("PLbar")
        assertNotNull(result)
        assertEquals("Bar", result!!.displayName)
    }

    @Test
    fun deleteById_removesPlaylist() = runTest {
        val id = dao.insert(PlaylistEntity(youtubePlaylistId = "PLdel", displayName = "Del"))
        dao.deleteById(id)
        assertEquals(0, dao.getAll().size)
    }

    @Test
    fun deleteById_cascadesVideos() = runTest {
        // In our fake, we just verify playlist is deleted.
        // Real cascade test is in instrumented tests with Room.
        val id = dao.insert(PlaylistEntity(youtubePlaylistId = "PLcasc", displayName = "Cascade"))
        dao.deleteById(id)
        assertNull(dao.getByYoutubeId("PLcasc"))
    }

    @Test
    fun count_returnsCorrectNumber() = runTest {
        repeat(5) { i ->
            dao.insert(PlaylistEntity(youtubePlaylistId = "PL$i", displayName = "Playlist $i"))
        }
        assertEquals(5, dao.count())
        // Delete 2
        val all = dao.getAll()
        dao.deleteById(all[0].id)
        dao.deleteById(all[1].id)
        assertEquals(3, dao.count())
    }

    @Test
    fun insertDuplicateYoutubeId_fails() = runTest {
        dao.insert(PlaylistEntity(youtubePlaylistId = "PLdup", displayName = "First"))
        try {
            dao.insert(PlaylistEntity(youtubePlaylistId = "PLdup", displayName = "Second"))
            fail("Should throw on duplicate youtube_playlist_id")
        } catch (e: IllegalStateException) {
            // expected
        }
    }

    @Test
    fun updateDisplayName_persists() = runTest {
        val id = dao.insert(PlaylistEntity(youtubePlaylistId = "PLupd", displayName = "Old Name"))
        dao.updateDisplayName(id, "New Name")
        val updated = dao.getByYoutubeId("PLupd")
        assertEquals("New Name", updated!!.displayName)
    }
}

/**
 * Fake DAO that mimics Room behavior for unit testing without Android.
 */
class FakePlaylistDao : PlaylistDao {
    private val store = mutableListOf<PlaylistEntity>()
    private var nextId = 1L

    override suspend fun insert(playlist: PlaylistEntity): Long {
        if (store.any { it.youtubePlaylistId == playlist.youtubePlaylistId }) {
            throw IllegalStateException("UNIQUE constraint failed: playlists.youtube_playlist_id")
        }
        val entity = playlist.copy(id = nextId++)
        store.add(entity)
        return entity.id
    }

    override suspend fun getAll(): List<PlaylistEntity> = store.sortedBy { it.addedAt }

    override suspend fun getByYoutubeId(youtubeId: String): PlaylistEntity? =
        store.find { it.youtubePlaylistId == youtubeId }

    override suspend fun deleteById(id: Long) {
        store.removeAll { it.id == id }
    }

    override suspend fun count(): Int = store.size

    override suspend fun deleteAll() {
        store.clear()
    }

    override suspend fun updateDisplayName(id: Long, name: String) {
        val idx = store.indexOfFirst { it.id == id }
        if (idx >= 0) {
            store[idx] = store[idx].copy(displayName = name)
        }
    }
}
