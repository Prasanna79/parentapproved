package tv.parentapproved.app.data

import tv.parentapproved.app.data.cache.ChannelDao
import tv.parentapproved.app.data.cache.ChannelEntity
import kotlinx.coroutines.test.runTest
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

class ChannelDaoTest {

    private lateinit var dao: FakeChannelDao

    @Before
    fun setup() {
        dao = FakeChannelDao()
    }

    @Test
    fun insertChannel_returnsAutoGeneratedId() = runTest {
        val id = dao.insert(ChannelEntity(sourceType = "yt_playlist", sourceId = "PLtest1", sourceUrl = "https://youtube.com/playlist?list=PLtest1", displayName = "Test 1"))
        assertTrue("Insert should return id > 0", id > 0)
    }

    @Test
    fun getAll_returnsInsertedChannels() = runTest {
        dao.insert(ChannelEntity(sourceType = "yt_playlist", sourceId = "PL1", sourceUrl = "url1", displayName = "A"))
        dao.insert(ChannelEntity(sourceType = "yt_video", sourceId = "vid1", sourceUrl = "url2", displayName = "B"))
        dao.insert(ChannelEntity(sourceType = "yt_channel", sourceId = "UC1", sourceUrl = "url3", displayName = "C"))
        assertEquals(3, dao.getAll().size)
    }

    @Test
    fun getBySourceId_returnsCorrectChannel() = runTest {
        dao.insert(ChannelEntity(sourceType = "yt_playlist", sourceId = "PLfoo", sourceUrl = "url1", displayName = "Foo"))
        dao.insert(ChannelEntity(sourceType = "yt_video", sourceId = "vid1", sourceUrl = "url2", displayName = "Bar"))
        val result = dao.getBySourceId("vid1")
        assertNotNull(result)
        assertEquals("Bar", result!!.displayName)
    }

    @Test
    fun deleteById_removesChannel() = runTest {
        val id = dao.insert(ChannelEntity(sourceType = "yt_playlist", sourceId = "PLdel", sourceUrl = "url", displayName = "Del"))
        dao.deleteById(id)
        assertEquals(0, dao.getAll().size)
    }

    @Test
    fun count_returnsCorrectNumber() = runTest {
        repeat(5) { i ->
            dao.insert(ChannelEntity(sourceType = "yt_playlist", sourceId = "PL$i", sourceUrl = "url$i", displayName = "P$i"))
        }
        assertEquals(5, dao.count())
    }

    @Test
    fun insertDuplicateSourceId_fails() = runTest {
        dao.insert(ChannelEntity(sourceType = "yt_playlist", sourceId = "PLdup", sourceUrl = "url", displayName = "First"))
        try {
            dao.insert(ChannelEntity(sourceType = "yt_playlist", sourceId = "PLdup", sourceUrl = "url", displayName = "Second"))
            fail("Should throw on duplicate source_id")
        } catch (e: IllegalStateException) {
            // expected
        }
    }

    @Test
    fun updateDisplayName_persists() = runTest {
        val id = dao.insert(ChannelEntity(sourceType = "yt_playlist", sourceId = "PLupd", sourceUrl = "url", displayName = "Old"))
        dao.updateDisplayName(id, "New Name")
        assertEquals("New Name", dao.getBySourceId("PLupd")!!.displayName)
    }

    @Test
    fun updateVideoCount_persists() = runTest {
        val id = dao.insert(ChannelEntity(sourceType = "yt_playlist", sourceId = "PLcnt", sourceUrl = "url", displayName = "Count"))
        dao.updateVideoCount(id, 42)
        assertEquals(42, dao.getBySourceId("PLcnt")!!.videoCount)
    }

    @Test
    fun updateMeta_persistsBoth() = runTest {
        val id = dao.insert(ChannelEntity(sourceType = "yt_channel", sourceId = "@test", sourceUrl = "url", displayName = "Old"))
        dao.updateMeta(id, "New Name", 99)
        val updated = dao.getBySourceId("@test")!!
        assertEquals("New Name", updated.displayName)
        assertEquals(99, updated.videoCount)
    }

    @Test
    fun deleteAll_clearsEverything() = runTest {
        repeat(3) { i ->
            dao.insert(ChannelEntity(sourceType = "yt_video", sourceId = "v$i", sourceUrl = "url$i", displayName = "V$i"))
        }
        dao.deleteAll()
        assertEquals(0, dao.count())
    }
}

/**
 * Fake DAO that mimics Room behavior for unit testing without Android.
 */
class FakeChannelDao : ChannelDao {
    private val store = mutableListOf<ChannelEntity>()
    private var nextId = 1L

    override suspend fun insert(channel: ChannelEntity): Long {
        if (store.any { it.sourceId == channel.sourceId }) {
            throw IllegalStateException("UNIQUE constraint failed: channels.source_id")
        }
        val entity = channel.copy(id = nextId++)
        store.add(entity)
        return entity.id
    }

    override suspend fun getAll(): List<ChannelEntity> = store.sortedBy { it.addedAt }

    override suspend fun getBySourceId(sourceId: String): ChannelEntity? =
        store.find { it.sourceId == sourceId }

    override suspend fun deleteById(id: Long) {
        store.removeAll { it.id == id }
    }

    override suspend fun count(): Int = store.size

    override suspend fun deleteAll() {
        store.clear()
    }

    override suspend fun updateDisplayName(id: Long, name: String) {
        val idx = store.indexOfFirst { it.id == id }
        if (idx >= 0) store[idx] = store[idx].copy(displayName = name)
    }

    override suspend fun updateVideoCount(id: Long, count: Int) {
        val idx = store.indexOfFirst { it.id == id }
        if (idx >= 0) store[idx] = store[idx].copy(videoCount = count)
    }

    override suspend fun updateMeta(id: Long, name: String, count: Int) {
        val idx = store.indexOfFirst { it.id == id }
        if (idx >= 0) store[idx] = store[idx].copy(displayName = name, videoCount = count)
    }
}
